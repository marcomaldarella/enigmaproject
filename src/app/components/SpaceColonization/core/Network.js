// Network.js
import { Defaults } from './Defaults';
import KDBush from 'kdbush';
import * as Vec2 from 'vec2';
import { random } from './Utilities';

export default class Network {
  constructor(ctx, settings) {
    this.ctx = ctx;
    this.settings = Object.assign({}, Defaults, settings);

    this.attractors = []; // attractors influence node growth
    this.nodes = []; // nodes are connected to form branches

    this.nodesIndex = null; // kd-bush spatial index for all nodes

    this.bounds = []; // array of Path objects that branches cannot grow outside of
    this.obstacles = []; // array of Path objects that branches must avoid

    this.buildSpatialIndices();
  }

  buildSpatialIndices() {
    // Create a new KDBush index with the number of points
    this.nodesIndex = new KDBush(this.nodes.length);

    // Add each point individually
    for (let i = 0; i < this.nodes.length; i++) {
      this.nodesIndex.add(this.nodes[i].position.x, this.nodes[i].position.y);
    }

    // Finish the indexing
    this.nodesIndex.finish();
  }

  reset() {
    this.nodes = [];
    this.attractors = [];

    this.buildSpatialIndices();
  }

  addNode(node) {
    this.nodes.push(node); // Add the node to the array
    this.buildSpatialIndices(); // Update spatial indices
  }

  getClosestNode(attractor, nearbyNodes) {
    if (
      !attractor ||
      !attractor.position ||
      typeof attractor.position.x === 'undefined' ||
      typeof attractor.position.y === 'undefined'
    ) {
      console.error("Invalid attractor or position", attractor);
      return null;
    }

    let closestNode = null;
    let record = this.settings.AttractionDistance;

    for (let node of nearbyNodes) {
      if (!node || !node.position || typeof node.position.distance !== 'function') {
        console.error("Invalid node or position", node);
        continue; // Salta nodi non validi
      }

      const distance = node.position.distance(attractor.position);

      if (distance < this.settings.KillDistance) {
        attractor.reached = true;
        closestNode = null;
      } else if (distance < record) {
        closestNode = node;
        record = distance;
      }
    }

    return closestNode;
  }

  getNodesInAttractionZone(attractor) {
    if (
      !attractor ||
      !attractor.position ||
      typeof attractor.position.x === 'undefined' ||
      typeof attractor.position.y === 'undefined'
    ) {
      console.error("Invalid attractor or position", attractor);
      return [];
    }

    return this.nodes.filter(node => {
      if (!node || !node.position) {
        console.error("Invalid node in nodes array", node);
        return false;
      }
      const distance = node.position.distance(attractor.position);
      return distance <= this.settings.AttractionDistance;
    });
  }


  updateColors(colors, invert = false) {
    if (colors.primary) {
      this.settings.Colors.primary = colors.primary;
    }
    if (colors.secondary) {
      this.settings.Colors.secondary = colors.secondary;
    }
    if (colors.BackgroundColor) {
      this.settings.Colors.BackgroundColor = colors.BackgroundColor;
    }

    // Applica il filtro di inversione se richiesto
    if (invert) {
      this.applyInvertFilter();
    }
  }

  update() {
    // Skip iteration if paused
    if (this.settings.IsPaused) {
      return;
    }

    // Associate attractors with nearby nodes to figure out where growth should occur
    for (let [attractorID, attractor] of this.attractors.entries()) {
      switch (this.settings.VenationType) {
        // For open venation, only associate this attractor with its closest node
        case 'Open':
          let closestNode = this.getClosestNode(
            attractor,
            this.getNodesInAttractionZone(attractor)
          );

          if (closestNode != null) {
            closestNode.influencedBy.push(attractorID);
            attractor.influencingNodes = [closestNode];
          }

          break;

        // For closed venation, associate this attractor with all nodes in its relative neighborhood
        case 'Closed':
          let neighborhoodNodes = this.getRelativeNeighborNodes(attractor);
          let nodesInKillZone = this.getNodesInKillZone(attractor);

          // Exclude nodes that are in the attractor's kill zone (these should stop growing)
          let nodesToGrow = neighborhoodNodes.filter(neighborNode => {
            return !nodesInKillZone.includes(neighborNode);
          });

          attractor.influencingNodes = neighborhoodNodes;

          if (nodesToGrow.length > 0) {
            attractor.fresh = false;

            for (let node of nodesToGrow) {
              node.influencedBy.push(attractorID);
            }
          }

          break;
      }
    }

    // Grow the network by adding new nodes onto any nodes being influenced by attractors
    for (let node of this.nodes) {
      if (node.influencedBy.length > 0) {
        let averageDirection = this.getAverageDirection(
          node,
          node.influencedBy.map(id => this.attractors[id])
        );
        let nextNode = node.getNextNode(averageDirection);
        let isInsideAnyBounds = false;
        let isInsideAnyObstacle = false;

        // Only allow root nodes inside of defined bounds
        if (this.bounds != undefined && this.bounds.length > 0) {
          for (let bound of this.bounds) {
            if (bound.contains(nextNode.position.x, nextNode.position.y)) {
              isInsideAnyBounds = true;
            }
          }
        }

        // Don't allow any root nodes that are inside of an obstacle
        if (this.obstacles != undefined && this.obstacles.length > 0) {
          for (let obstacle of this.obstacles) {
            if (obstacle.contains(nextNode.position.x, nextNode.position.y)) {
              isInsideAnyObstacle = true;
            }
          }
        }

        // NOTE: disabling this check lets nodes grow across gaps in bounds - cool effect!
        if (
          (isInsideAnyBounds || this.bounds.length === 0) &&
          (!isInsideAnyObstacle || this.obstacles.length === 0)
        ) {
          this.nodes.push(nextNode);
        }
      }

      node.influencedBy = [];

      // Perform auxin flux canalization (line segment thickening)
      if (node.isTip && this.settings.EnableCanalization) {
        let currentNode = node;

        while (currentNode.parent != null) {
          // When there are multiple child nodes, use the thickest of them all
          if (currentNode.parent.thickness < currentNode.thickness + 0.07) {
            currentNode.parent.thickness = currentNode.thickness + 0.03;
          }

          currentNode = currentNode.parent;
        }
      }
    }

    // Remove any attractors that have been reached by their associated nodes
    for (let [attractorID, attractor] of this.attractors.entries()) {
      switch (this.settings.VenationType) {
        // For open venation, remove the attractor as soon as any node reaches it
        case 'Open':
          if (attractor.reached) {
            this.attractors.splice(attractorID, 1);
          }

          break;

        // For closed venation, remove the attractor only when all associated nodes have reached it
        case 'Closed':
          if (attractor.influencingNodes.length > 0 && !attractor.fresh) {
            let allNodesReached = true;

            for (let node of attractor.influencingNodes) {
              if (
                node.position.distance(attractor.position) >
                this.settings.KillDistance
              ) {
                allNodesReached = false;
              }
            }

            if (allNodesReached) {
              this.attractors.splice(attractorID, 1);
            }
          }

          break;
      }
    }

    // Rebuild spatial indices
    this.buildSpatialIndices();
  }

  draw() {
    this.drawBackground();
    this.drawBounds();
    this.drawObstacles();
    this.drawAttractors();
    this.drawNodes();
  }

  applyInvertFilter() {
    this.ctx.save(); // Salva lo stato attuale del canvas
    this.ctx.globalCompositeOperation = 'difference';
    this.ctx.fillStyle = 'white';
    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore(); // Ripristina lo stato del canvas
  }



  drawBackground() {
    this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

    this.ctx.beginPath();
    this.ctx.fillStyle = this.settings.Colors.BackgroundColor;
    this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
  }

  drawBounds() {
    if (this.settings.ShowBounds && this.bounds != undefined) {
      for (let bound of this.bounds) {
        bound.draw();
      }
    }
  }

  drawObstacles() {
    if (this.settings.ShowObstacles && this.obstacles != undefined) {
      for (let obstacle of this.obstacles) {
        obstacle.draw();
      }
    }
  }

  drawNodes() {
    if (this.settings.ShowNodes) {
      for (let node of this.nodes) {
        node.draw();
      }
    }
  }

  drawAttractors() {
    for (let attractor of this.attractors) {
      attractor.draw();

      // Draw lines between each attractor and the nodes they are influencing
      if (
        this.settings.ShowInfluenceLines &&
        attractor.influencingNodes.length > 0
      ) {
        for (let node of attractor.influencingNodes) {
          this.ctx.beginPath();
          this.ctx.moveTo(attractor.position.x, attractor.position.y);
          this.ctx.lineTo(node.position.x, node.position.y);
          this.ctx.strokeStyle = this.settings.Colors.InfluenceLinesColor;
          this.ctx.stroke();
        }
      }
    }
  }

  getRelativeNeighborNodes(attractor) {
    let fail

    let nearbyNodes = this.getNodesInAttractionZone(attractor)
    let relativeNeighbors = []
    let attractorToP0, attractorToP1, p0ToP1

    // p0 is a relative neighbor of auxinPos iff
    // for any point p1 that is closer to auxinPos than is p0,
    // p0 is closer to auxinPos than to p1
    for (let p0 of nearbyNodes) {
      fail = false
      attractorToP0 = p0.position.subtract(attractor.position, true)

      for (let p1 of nearbyNodes) {
        if (p0 === p1) {
          continue
        }

        attractorToP1 = p1.position.subtract(attractor.position, true)

        if (attractorToP1.length() > attractorToP0.length()) {
          continue
        }

        p0ToP1 = p1.position.subtract(p0.position, true)

        if (attractorToP0.length() > p0ToP1.length()) {
          fail = true
          break
        }
      }

      if (!fail) {
        relativeNeighbors.push(p0)
      }
    }

    return relativeNeighbors
  }

  getNodesInAttractionZone(attractor) {
    return this.nodesIndex
      .within(
        attractor.position.x,
        attractor.position.y,
        this.settings.AttractionDistance
      )
      .map(id => this.nodes[id])
  }

  getNodesInKillZone(attractor) {
    return this.nodesIndex
      .within(
        attractor.position.x,
        attractor.position.y,
        this.settings.KillDistance
      )
      .map(id => this.nodes[id])
  }

  getClosestNode(attractor, nearbyNodes) {
    let closestNode = null,
      record = this.settings.AttractionDistance

    for (let node of nearbyNodes) {
      let distance = node.position.distance(attractor.position)

      if (distance < this.settings.KillDistance) {
        attractor.reached = true
        closestNode = null
      } else if (distance < record) {
        closestNode = node
        record = distance
      }
    }

    return closestNode
  }

  getAverageDirection(node, nearbyattractors) {
    // Add up normalized vectors pointing to each attractor
    let averageDirection = new Vec2(0, 0)

    for (let attractor of nearbyattractors) {
      averageDirection.add(
        attractor.position.subtract(node.position, true).normalize()
      )
    }

    // Add small amount of random "jitter" to avoid getting stuck between two attractors and endlessly generating nodes in the same place
    // (Credit to Davide Prati (edap) for the idea, seen in ofxSpaceColonization)
    averageDirection
      .add(new Vec2(random(-0.1, 0.1), random(-0.1, 0.1)))
      .normalize()

    averageDirection.divide(node.influencedBy.length).normalize()

    return averageDirection
  }

  addNode(node) {
    let isInsideAnyBounds = false
    let isInsideAnyObstacle = false

    // Only allow root nodes inside of defined bounds
    if (this.bounds != undefined && this.bounds.length > 0) {
      for (let bound of this.bounds) {
        if (bound.contains(node.position.x, node.position.y)) {
          isInsideAnyBounds = true
        }
      }
    }

    // Don't allow any root nodes that are inside of an obstacle
    if (this.obstacles != undefined && this.obstacles.length > 0) {
      for (let obstacle of this.obstacles) {
        if (obstacle.contains(node.position.x, node.position.y)) {
          isInsideAnyObstacle = true
        }
      }
    }

    if (
      (isInsideAnyBounds || this.bounds.length === 0) &&
      (!isInsideAnyObstacle || this.obstacles.length === 0)
    ) {
      this.nodes.push(node)
      this.buildSpatialIndices()
    }
  }

  reset() {
    this.nodes = []
    this.attractors = []

    this.buildSpatialIndices()
  }

  buildSpatialIndices() {
    // Create a new KDBush index with the number of points
    this.nodesIndex = new KDBush(this.nodes.length)

    // Add each point individually
    for (let i = 0; i < this.nodes.length; i++) {
      this.nodesIndex.add(this.nodes[i].position.x, this.nodes[i].position.y)
    }

    // Finish the indexing
    this.nodesIndex.finish()
  }

  toggleNodes() {
    this.settings.ShowNodes = !this.settings.ShowNodes
  }

  toggleTips() {
    this.settings.ShowTips = !this.settings.ShowTips

    for (let node of this.nodes) {
      node.settings.ShowTips = !node.settings.ShowTips
    }
  }

  toggleattractors() {
    this.settings.Showattractors = !this.settings.Showattractors

    for (let attractor of this.attractors) {
      attractor.settings.Showattractors = !attractor.settings.Showattractors
    }
  }

  toggleAttractionZones() {
    this.settings.ShowAttractionZones = !this.settings.ShowAttractionZones

    for (let attractor of this.attractors) {
      attractor.settings.ShowAttractionZones =
        !attractor.settings.ShowAttractionZones
    }
  }

  toggleKillZones() {
    this.settings.ShowKillZones = !this.settings.ShowKillZones

    for (let attractor of this.attractors) {
      attractor.settings.ShowKillZones = !attractor.settings.ShowKillZones
    }
  }

  toggleInfluenceLines() {
    this.settings.ShowInfluenceLines = !this.settings.ShowInfluenceLines
  }

  toggleBounds() {
    this.settings.ShowBounds = !this.settings.ShowBounds
  }

  toggleObstacles() {
    this.settings.ShowObstacles = !this.settings.ShowObstacles
  }

  toggleCanalization() {
    this.settings.EnableCanalization = !this.settings.EnableCanalization

    if (!this.settings.EnableCanalization) {
      for (let node of this.nodes) {
        node.thickness = 0
      }
    }
  }

  toggleOpacityBlending() {
    this.settings.EnableOpacityBlending = !this.settings.EnableOpacityBlending

    for (let node of this.nodes) {
      node.settings.EnableOpacityBlending = this.settings.EnableOpacityBlending
    }
  }

  togglePause() {
    this.settings.IsPaused = !this.settings.IsPaused
  }



}




